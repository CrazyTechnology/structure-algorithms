1.排序的稳定性
    排序之后的结果每次都相同。尤其是针对有有相同大小的值的时候，每次输出的位置要相同
2.内排序是在排序的整个过程中，待排序的所有记录全都放置在内存中
3。外排序是由于排序的记录个数太多，不能同时放置在内存中。整个过程需要内外存之间多次交换数据才行
4。排序算法的性能
    时间复杂度、空间复杂度、算法复杂度

5。内排序分类
    插入排序，交换排序、选择排序、归并排序

6。冒泡排序（双重for循环遍历）时间复杂度O(n)^2
  数组  1 3 5 7 8 6 4         数组长度为7，下标为0-6

  这种写法不是正宗的冒泡排序，只能保证在一次遍历完成之后第一个是最大值或最小值
  for(int i=0;i<arrays.length;i++)
    for(int j=i+1;j<=arrays.length;j++)
        if(arrays[i]>arrays[j])
            swap(arrays,i,j)   //交换位置
   交换过程拆解
   i=0
   1 3 5 7 8 6 4
   i=1
   1 3 5 7 8 6 4
   i=2
   1 3 4 7 8 6 5 (交换4，5的位置)
   i=3
   1 3 4 6 8 7 5 (第一次交换)

   1 3 4 5 8 7 6  （第二次交换）

   i=4
   1 3 4 5 7 8 6

   1 3 4 5 6 8 7
   i=5
   1 3 4 5 6 7 8
   i=6
   for(int j=i+1;j<=arrays.length;j++)
   这个条件不满足，跳出执行

   上个版本冒泡排序的优化
   for(int i=0;i<arrays.length;i++)
    for(int j=arrays.length-1;j>=i;j--)
        if(arrays[j]>arrays[j+1])
            swap(arrays,j,j+1)

   交换过程拆解
   数组  1 3 5 7 8 6 4         数组长度为7，下标为0-6
   i=0
   1 3 5 7 8 4 6
   1 3 5 7 4 8 6
   1 3 5 4 7 8 6
   1 3 4 5 7 8 6
   i=1
   1 3 4 5 7 6 8
   1 3 4 5 6 7 8
   i=2,3,4,5,6遍历之后没有满足交换的条件。所以不展示

7.简单选择排序
    时间复杂度O(n)^2  双重for循环
    交换移动数据次数少，性能略优于冒泡排序
交换过程拆解
   数组  1 3 5 7 8 6 4         数组长度为7，下标为0-6

   i=0
   不需要交换
   i=1
   不需要交换
   i=2
   1 3 4 7 8 6 5
   i=3
   1 3 4 5 8 6 7
   i=4
   1 3 4 5 6 8 7
   i=5
   1 3 4 5 6 7 8



